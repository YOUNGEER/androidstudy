package com.wy.younger.java.threads.chapter4


/**
 *在前台运行的线程称为 用户线程，运行在后台的线程称为守护线程
 *
 * 守护线程一般是为用户线程服务的，
 *
 *
 *
 *
 * 1.守护线程必须在设置isDaemon后再能调用start方法
 * 2.守护线程中开辟的线程也算守护线程
 * 3.守护线程中不要执行逻辑任务，防止用户线程都结束了、守护线程还在执行
 *
 *
 */

fun main(args: Array<String>) {
    val thread = Thread("thread1")
    thread.isDaemon = true
    thread.start()
}


/**


线程阻塞


    线程可以阻塞于四种状态：

    1、当线程执行Thread.sleep（）时，它一直阻塞到指定的毫秒时间之后，或者阻塞被另一个线程打断；

    2、当线程碰到一条wait（）语句时，它会一直阻塞到接到通知（notify（））、被中断或经过了指定毫秒时间为止（若制定了超时值的话）

    3、线程阻塞与不同I/O的方式有多种。常见的一种方式是InputStream的read（）方法，该方法一直阻塞到从流中读取一个字节的数据为止，它可以无限阻塞，因此不能指定超时时间；

    4、线程也可以阻塞等待获取某个对象锁的排他性访问权限（即等待获得synchronized语句必须的锁时阻塞）。



    注意，并非所有的阻塞状态都是可中断的，以上阻塞状态的前两种可以被中断，后两种不会对中断做出反应
 */